<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="Place to share my thoughts and experiences in the tech world.">
    <meta name="keywords" content="Artificial Intelligence, Software Development, Algorithm Analysis, My Understandings">
    <meta name="theme-color" content="#000000">

    <!-- Open Graph -->
    <meta property="og:title"
        content="Simple Segment Tree - Shreyas's Blog">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="The lessons learned from optimizing binary search can be applied to a broad range of data structures.
">
    
    <meta property="article:published_time" content=" 2025-07-25T00:00:00Z">
    
    
    <meta property="article:author" content="Shreyas S N">
    
    
    <meta property="article:tag" content="Algorithms">
    
    
    <meta property="og:image" content="http://localhost:4000https://github.com/shreyassn.png">
    <meta property="og:url" content="http://localhost:4000/2025/07/25/segment-tree/">
    <meta property="og:site_name" content="Shreyas's Blog">

    <title>Simple Segment Tree - Shreyas's Blog</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">

    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:4000/2025/07/25/segment-tree/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">
    <link rel="stylesheet" href="/css/blogs.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400..900;1,400..900&display=swap" rel="stylesheet"> -->
    <link href="https://fonts.googleapis.com/css2?family=Cormorant:ital,wght@0,400..900;1,400..900&display=swap" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>

    <!-- Google AdSense -->
    <script data-ad-client="ca-pub-6487568398225121" async
        src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="blog-full-content">

    <!-- Navigation -->

    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">Shreyas's Blogs</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div id="huxblog_navbar">
                <div class="navbar-collapse">
                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="/">Home</a>
                        </li>
                        
                        
                        
                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                        
                        
                        <li>
                            <a href="/archive/">Archive</a>
                        </li>
                        
                        
                        
                        <li>
                            <a href="/arts/">Arts</a>
                        </li>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <li class="search-icon">
                            <a href="javascript:void(0)">
                                <i class="fa fa-search"></i>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <script>
        // Drop Bootstarp low-performance Navbar
        // Use customize navbar with high-quality material design animation
        // in high-perf jank-free CSS3 implementation
        var $body = document.body;
        var $toggle = document.querySelector('.navbar-toggle');
        var $navbar = document.querySelector('#huxblog_navbar');
        var $collapse = document.querySelector('.navbar-collapse');

        var __HuxNav__ = {
            close: function () {
                $navbar.className = " ";
                // wait until animation end.
                setTimeout(function () {
                    // prevent frequently toggle
                    if ($navbar.className.indexOf('in') < 0) {
                        $collapse.style.height = "0px"
                    }
                }, 400)
            },
            open: function () {
                $collapse.style.height = "auto"
                $navbar.className += " in";
            }
        }

        // Bind Event
        $toggle.addEventListener('click', function (e) {
            if ($navbar.className.indexOf('in') > 0) {
                __HuxNav__.close()
            } else {
                __HuxNav__.open()
            }
        })

        /**
         * Since Fastclick is used to delegate 'touchstart' globally
         * to hack 300ms delay in iOS by performing a fake 'click',
         * Using 'e.stopPropagation' to stop 'touchstart' event from 
         * $toggle/$collapse will break global delegation.
         * 
         * Instead, we use a 'e.target' filter to prevent handler
         * added to document close HuxNav.  
         *
         * Also, we use 'click' instead of 'touchstart' as compromise
         */
        document.addEventListener('click', function (e) {
            if (e.target == $toggle) return;
            if (e.target.className == 'icon-bar') return;
            __HuxNav__.close();
        })
    </script>
    <!-- Search -->
<div class="search-page">
  <div class="search-icon-close-container">
    <span class="search-icon-close">
      <i class="fa fa-chevron-down"></i>
    </span>
  </div>
  <div class="search-main container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <form></form>
        <input type="text" id="search-input" placeholder="$ grep...">
        </form>
        <div id="search-results" class="mini-post-list"></div>
      </div>
    </div>
  </div>
</div>

    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/post/segtree.png" width="0" height="0"> -->

<!-- Post Header -->



<style type="text/css">
  header.intro-header {
    position: relative;
    background-image: url('/img/post/segtree.png');

    background: {
        {
        page.header-bg-css
      }
    }

    ;
  }

    {
    % if page.header-mask %
  }

  header.intro-header .header-mask {
    width: 100%;
    height: 100%;
    position: absolute;

    background: rgba(0, 0, 0, {
        {
        page.header-mask
      }
    });
  }

    {
    % endif %
  }
</style>




  <header class="intro-header">
    
    <div class="header-mask"></div>
    
    <div class="container-fluid">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          <div class="post-heading">
            <div class="tags">
              
              <a class="tag" href="/archive/?tag=Algorithms" title="Algorithms">Algorithms</a>
              
            </div>
            <h1>Simple Segment Tree</h1>
            
            <h2 class="subheading">All patterns of classical dp</h2>
            <span class="meta">Posted by Shreyas S N on
              July 25, 2025</span>
          </div>
        </div>
      </div>
    </div>
  </header>
  

  

  

<!-- Post Content -->
<article>
  <div class="container-fluid">
    <div class="row">

      <!-- Post Container -->
      <div class="
                col-lg-9 col-lg-offset-1
                col-md-10 col-md-offset-0
                post-container">

        <!-- Multi-Lingual -->
        

        <p>The lessons learned from <a href="../s-tree">optimizing</a> <a href="../binary-search">binary search</a> can be applied to a broad range of data structures.</p>

<p>In this article, instead of trying to optimize something from the STL again, we focus on <em>segment trees</em>, the structures that may be unfamiliar to most <em>normal</em> programmers and perhaps even most computer science researchers<sup id="fnref:tcs"><a href="#fn:tcs" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>, but that are used <a href="https://www.google.com/search?q=segment+tree+site%3Acodeforces.com&amp;newwindow=1&amp;sxsrf=APq-WBuTupSOnSn9JNEHhaqtmv0Uq0eogQ%3A1645969931499&amp;ei=C4IbYrb2HYibrgS9t6qgDQ&amp;ved=0ahUKEwj2p8_og6D2AhWIjYsKHb2bCtQQ4dUDCA4&amp;uact=5&amp;oq=segment+tree+site%3Acodeforces.com&amp;gs_lcp=Cgdnd3Mtd2l6EAM6BwgAEEcQsAM6BwgAELADEEM6BAgjECc6BAgAEEM6BQgAEIAEOgYIABAWEB46BQghEKABSgQIQRgASgQIRhgAUMkFWLUjYOgkaANwAXgAgAHzAYgB9A-SAQYxNS41LjGYAQCgAQHIAQrAAQE&amp;sclient=gws-wiz">very extensively</a> in programming competitions for their speed and simplicity of implementation.</p>

<p>(If you already know the context, jump straight to the <a href="#wide-segment-trees">last section</a> for the novelty: the <em>wide segment tree</em> that works 4 to 12 times faster than the Fenwick tree.)</p>

<h3 id="dynamic-prefix-sum">Dynamic Prefix Sum</h3>

<!--

This is a long article, and to make it less long, we will mostly be focusing on its simplest application -->

<p>Segment trees are cool and can do lots of different things, but in this article, we will focus on their simplest non-trivial application — <em>the dynamic prefix sum problem</em>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// react to a[k] += x (zero-based indexing)</span>
<span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">);</span>         <span class="c1">// return the sum of the first k elements (from 0 to k - 1)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>As we have to support two types of queries, our optimization problem becomes multi-dimensional, and the optimal solution depends on the distribution of queries. For example, if one type of the queries were extremely rare, we would only optimize for the other, which is relatively easy to do:</p>

<ul>
  <li>If we only cared about the cost of <em>updating the array</em>, we would store it as it is and <a href="/hpc/simd/reduction">calculate the sum</a> directly on each <code class="language-plaintext highlighter-rouge">sum</code> query.</li>
  <li>If we only cared about the cost of <em>prefix sum queries</em>, we would keep it ready and <a href="/hpc/algorithms/prefix">re-calculate them entirely from scratch</a> on each update.</li>
</ul>

<p>Both of these options perform $O(1)$ work on one query type but $O(n)$ work on the other. When the query frequencies are relatively close, we can trade off some performance on one type of query for increased performance on the other. Segment trees let you do exactly that, achieving the equilibrium of $O(\log n)$ work for both queries.</p>

<h3 id="segment-tree-structure">Segment Tree Structure</h3>

<p>The main idea behind segment trees is this:</p>

<ul>
  <li>calculate the sum of the entire array and write it down somewhere;</li>
  <li>split the array into two halves, calculate the sum on both halves, and also write them down somewhere;</li>
  <li>split these halves into halves, calculate the total of four sums on them, and also write them down;</li>
  <li>…and so on, until we recursively reach segments of length one.</li>
</ul>

<p>These computed subsegment sums can be logically represented as a binary tree — which is what we call a <em>segment tree</em>:</p>

<p><img src="../img/segtree-path.png" alt="A segment tree with with the nodes relevant for the sum(11) and add(10) queries highlighted" /></p>

<p>Segment trees have some nice properties:</p>

<ul>
  <li>If the underlying array has $n$ elements, the segment tree has exactly $(2n - 1)$ nodes — $n$ leaves and $(n - 1)$ internal nodes — because each internal node splits a segment in two, and you only need $(n - 1)$ of them to completely split the original $[0, n-1]$ range.</li>
  <li>The height of the tree is $\Theta(\log n)$: on each next level starting from the root, the number of nodes roughly doubles and the size of their segments roughly halves.</li>
  <li>Each segment can be split into $O(\log n)$ non-intersecting segments that correspond to the nodes of the segment tree: you need at most two from each layer.</li>
</ul>

<p>When $n$ is not a perfect power of two, not all levels are filled entirely — the last layer may be incomplete — but the truthfulness of these properties remains unaffected. The first property allows us to use only $O(n)$ memory to store the tree, and the last two let us solve the problem in $O(\log n)$ time:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">add(k, x)</code> query can be handled by adding the value <code class="language-plaintext highlighter-rouge">x</code> to all nodes whose segments contain the element <code class="language-plaintext highlighter-rouge">k</code>, and we’ve already established that there are only $O(\log n)$ of them.</li>
  <li>The <code class="language-plaintext highlighter-rouge">sum(k)</code> query can be answered by finding all nodes that collectively compose the <code class="language-plaintext highlighter-rouge">[0, k)</code> prefix and summing the values stored in them — and we’ve also established that there would be at most $O(\log n)$ of them.</li>
</ul>

<p>But this is still theory. As we’ll see later, there are remarkably many ways one can implement this data structure.</p>

<!--

Note that by the same logic that each prefix can be covered by $O(\log n)$ nodes, each possible segment can also be covered by $O(\log n)$ nodes: you just possibly need at most two of them on each level. This lets us compute sums on any segment, although in this article we are not going to do it, instead reducing it to computing two prefix sums (from the right border, and the subtracting the prefix sum on the left border).

This is a general idea. Many different implementations possible, which we will explore one by one in this article.

Segment trees are built recursively: build a tree for left and right halves and merge results to get root.

Depending on the relative frequencies of the query types, the optimal solution may differ.

One way to do this is through a trick commonly called *square root decomposition*: we split the array (of size $n$) into blocks of approximately $\sqrt n$ elements,

sqrt

Enable [hugepages](/hpc/cpu-cache/paging) system-wide and forget about it.

Most of examples in this section are about optimizing some algorithms that are either included in standard library or take under 10 lines of code to implement naively, but we will start off with a bit more obscure example.

There are many things segment trees can do. Persistent structures, computational geometry. But for most of this article, we will focus on the dynamic (as opposed to static) prefix sum problem.

Segment trees are used for windowing queries or range queries in general, either by themselves or as part of a larger algorithm.

Functional programming, e.g., for implementing persistent arrays and derived structures.

-->

<h3 id="pointer-based-implementation">Pointer-Based Implementation</h3>

<p>The most straightforward way to implement a segment tree is to store everything we need in a node explicitly: including the array segment boundaries, the sum, and the pointers to its children.</p>

<p>If we were at the “Introduction to OOP” class, we would implement a segment tree recursively like this:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">segtree</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">lb</span><span class="p">,</span> <span class="n">rb</span><span class="p">;</span>                         <span class="c1">// the range this node is responsible for </span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                          <span class="c1">// the sum of elements [lb, rb)</span>
    <span class="n">segtree</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="c1">// pointers to its children</span>

    <span class="n">segtree</span><span class="p">(</span><span class="kt">int</span> <span class="n">lb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rb</span><span class="p">)</span> <span class="o">:</span> <span class="n">lb</span><span class="p">(</span><span class="n">lb</span><span class="p">),</span> <span class="n">rb</span><span class="p">(</span><span class="n">rb</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">lb</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">rb</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// if the node is not a leaf, create children</span>
            <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">lb</span> <span class="o">+</span> <span class="n">rb</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="n">segtree</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
            <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="n">segtree</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* react to a[k] += x */</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* compute the sum of the first k elements */</span> <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>If we needed to build it over an existing array, we would rewrite the body of the constructor like this:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">lb</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">rb</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">lb</span><span class="p">];</span> <span class="c1">// the node is a leaf -- its sum is just the element a[lb]</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">lb</span> <span class="o">+</span> <span class="n">rb</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="n">segtree</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
    <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="n">segtree</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">+</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">;</span> <span class="c1">// we can use the sums of children that we've just calculated</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The construction time is of no significant interest to us, so to reduce the mental burden, we will just assume that the array is zero-initialized in all future implementations.</p>

<p>Now, to implement <code class="language-plaintext highlighter-rouge">add</code>, we need to descend down the tree until we reach a leaf node, adding the delta to the <code class="language-plaintext highlighter-rouge">s</code> fields:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// check whether it is a leaf node</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">)</span>
            <span class="n">l</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">r</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<!--

We can do largely the same with the prefix sum query, adding the sum stored in the left node each time we go right:

-->

<p>To calculate the sum on a segment, we can check if the query covers the current segment fully or doesn’t intersect with it at all — and return the result for this node right away. If neither is the case, we recursively pass the query to the children so that they figure it out themselves:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">lq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rq</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rb</span> <span class="o">&lt;=</span> <span class="n">lq</span> <span class="o">&amp;&amp;</span> <span class="n">rb</span> <span class="o">&lt;=</span> <span class="n">rq</span><span class="p">)</span> <span class="c1">// if we're fully inside the query, return the sum</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rq</span> <span class="o">&lt;=</span> <span class="n">lb</span> <span class="o">||</span> <span class="n">lq</span> <span class="o">&gt;=</span> <span class="n">rb</span><span class="p">)</span> <span class="c1">// if we don't intersect with the query, return zero</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">sum</span><span class="p">(</span><span class="n">lq</span><span class="p">,</span> <span class="n">rq</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">sum</span><span class="p">(</span><span class="n">lq</span><span class="p">,</span> <span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This function visits a total of $O(\log n)$ nodes because it only spawns children when a segment only partially intersects with the query, and there are at most $O(\log n)$ of such segments.</p>

<p>For <em>prefix sums</em>, these checks can be simplified as the left border of the query is always zero:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rb</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lb</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">sum</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">sum</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Since we have two types of queries, we also got two graphs to look at:</p>

<p><img src="../img/segtree-pointers.svg" alt="" /></p>

<p>While this object-oriented implementation is quite good in terms of software engineering practices, there are several aspects that make it terrible in terms of performance:</p>

<ul>
  <li>Both query implementations use <a href="/hpc/architecture/functions">recursion</a> — although the <code class="language-plaintext highlighter-rouge">add</code> query can be tail-call optimized.</li>
  <li>Both query implementations use unpredictable <a href="/hpc/pipelining/branching">branching</a>, which stalls the CPU pipeline.</li>
  <li>The nodes store extra metadata. The structure takes $4+4+4+8+8=28$ bytes and gets padded to 32 bytes for <a href="/hpc/cpu-cache/alignment">memory alignment</a> reasons, while only 4 bytes are really necessary to hold the integer sum.</li>
  <li>Most importantly, we are doing a lot of <a href="/hpc/cpu-cache/latency">pointer chasing</a>: we have to fetch the pointers to the children to descend into them, even though we can infer, ahead of time, which segments we’ll need just from the query.</li>
</ul>

<p>Pointer chasing outweighs all other issues by orders of magnitude — and to negate it, we need to get rid of pointers, making the structure <em>implicit</em>.</p>

<h3 id="implicit-segment-trees">Implicit Segment Trees</h3>

<p>As a segment tree is a type of binary tree, we can use the <a href="../binary-search#eytzinger-layout">Eytzinger layout</a> to store its nodes in one large array and use index arithmetic instead of explicit pointers to navigate it.</p>

<p>More formally, we define node $1$ to be the root, holding the sum of the entire array $[0, n)$. Then, for every node $v$ corresponding to the range $[l, r]$, we define:</p>

<ul>
  <li>the node $2v$ to be its left child corresponding to the range $[l, \lfloor \frac{l+r}{2} \rfloor)$;</li>
  <li>the node $(2v+1)$ to be its right child corresponding to the range $[\lfloor \frac{l+r}{2} \rfloor, r)$.</li>
</ul>

<p>When $n$ is a perfect power of two, this layout packs the entire tree very nicely:</p>

<p><img src="../img/segtree-layout.png" alt="The memory layout of the implicit segment tree with the same query path highlighted" /></p>

<p>However, when $n$ is not a power of two, the layout stops being compact: although we still have exactly $(2n - 1)$ nodes regardless of how we split segments, they are no longer mapped perfectly to the $[1, 2n)$ range.</p>

<p>For example, consider what happens when we descend to the rightmost leaf in a segment tree of size $17 = 2^4 + 1$:</p>

<ul>
  <li>we start with the root numbered $1$ representing the range $[0, 16]$,</li>
  <li>we go to node $3 = 2 \times 1 + 1$ representing the range $[8, 16]$,</li>
  <li>we go to node $7 = 2 \times 2 + 1$ representing the range $[12, 16]$,</li>
  <li>we go to node $15 = 2 \times 7 + 1$ representing the range $[14, 16]$,</li>
  <li>we go to node $31 = 2 \times 15 + 1$ representing the range $[15, 16]$,</li>
  <li>and we finally reach node $63 = 2 \times 31 + 1$ representing the range $[16, 16]$.</li>
</ul>

<p>So, as $63 &gt; 2 \times 17 - 1 = 33$, there are some empty spaces in the layout, but the structure of the tree is still the same, and its height is still $O(\log n)$. For now, we can ignore this problem and just allocate a larger array for storing the nodes — it can be shown that the index of the rightmost leaf never exceeds $4n$, so allocating that many cells will always suffice:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">t</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">N</span><span class="p">];</span> <span class="c1">// contains the node sums</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now, to implement <code class="language-plaintext highlighter-rouge">add</code>, we create a similar recursive function but using index arithmetic instead of pointers. Since we’ve also stopped storing the borders of the segment in the nodes, we need to re-calculate them and pass them as parameters for each recursive call:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The implementation of the prefix sum query is largely the same:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
         <span class="o">+</span> <span class="n">sum</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Passing around five variables in a recursive function seems clumsy, but the performance gains are clearly worth it:</p>

<p><img src="../img/segtree-topdown.svg" alt="" /></p>

<p>Apart from requiring much less memory, which is good for fitting into the CPU caches, the main advantage of this implementation is that we can now make use of the <a href="/hpc/cpu-cache/mlp">memory parallelism</a> and fetch the nodes we need in parallel, considerably improving the running time for both queries.</p>

<p>To improve the performance further, we can:</p>

<ul>
  <li>manually optimize the index arithmetic (e.g., noticing that we need to multiply <code class="language-plaintext highlighter-rouge">v</code> by <code class="language-plaintext highlighter-rouge">2</code> either way),</li>
  <li>replace division by two with an explicit binary shift (because <a href="/hpc/compilation/contracts/#arithmetic">compilers aren’t always able to do it themselves</a>),</li>
  <li>and, most importantly, get rid of <a href="/hpc/architecture/functions">recursion</a> and make the implementation fully iterative.</li>
</ul>

<p>As <code class="language-plaintext highlighter-rouge">add</code> is tail-recursive and has no return value, it is easy turn it into a single <code class="language-plaintext highlighter-rouge">while</code> loop:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">v</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">v</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Doing the same for the <code class="language-plaintext highlighter-rouge">sum</code> query is slightly harder as it has two recursive calls. The key trick is to notice that when we make these calls, one of them is guaranteed to terminate immediately as <code class="language-plaintext highlighter-rouge">k</code> can only be in one of the halves, so we can simply check this condition before descending the tree:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">N</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">v</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">++</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">m</span><span class="p">)</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This doesn’t improve the performance for the update query by a lot (because it was tail-recursive, and the compiler already performed a similar optimization), but the running time on the prefix sum query has roughly halved for all problem sizes:</p>

<p><img src="../img/segtree-iterative.svg" alt="" /></p>

<p>This implementation still has some problems: we are using up to twice as much memory as necessary, we have costly <a href="/hpc/pipelining/branching">branching</a>, and we have to maintain and re-compute array bounds on each iteration. To get rid of these problems, we need to change our approach a little bit.</p>

<h3 id="bottom-up-implementation">Bottom-Up Implementation</h3>

<p>Let’s change the definition of the implicit segment tree layout. Instead of relying on the parent-to-child relationship, we first forcefully assign all the leaf nodes numbers in the  $[n, 2n)$ range, and then recursively define the parent of node $k$ to be equal to node $\lfloor \frac{k}{2} \rfloor$.</p>

<p>This structure is largely the same as before: you can still reach the root (node $1$) by dividing any node number by two, and each node still has at most two children: $2k$ and $(2k + 1)$, as anything else yields a different parent number when floor-divided by two. The advantage we get is that we’ve forced the last layer to be contiguous and start from $n$, so we can use the array of half the size:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">];</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>When $n$ is a power of two, the structure of the tree is exactly the same as before and when implementing the queries, we can take advantage of this bottom-up approach and start from the $k$-th leaf node (simply indexed $N + k$) and ascend the tree until we reach the root:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">k</span> <span class="o">+=</span> <span class="n">N</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">k</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>To calculate the sum on the $[l, r)$ subsegment, we can maintain pointers to the first and the last element that needs to be added, increase/decrease them respectively when we add a node and stop after they converge to the same node (which would be their least common ancestor):</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">l</span> <span class="o">+=</span> <span class="n">N</span><span class="p">;</span>
    <span class="n">r</span> <span class="o">+=</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">l</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span><span class="p">[</span><span class="n">l</span><span class="o">++</span><span class="p">];</span> <span class="c1">// l is a right child: add it and move to a cousin</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">r</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span><span class="p">[</span><span class="n">r</span><span class="o">--</span><span class="p">];</span> <span class="c1">// r is a left child: add it and move to a cousin</span>
        <span class="n">l</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Surprisingly, both queries work correctly even when $n$ is not a power of two. To understand why, consider a 13-element segment tree:</p>

<p><img src="../img/segtree-permuted.png" alt="" /></p>

<p>The first index of the last layer is always a power of two, but when the array size is not a perfect power of two, some prefix of the leaf elements gets wrapped around to the right side of the tree. Magically, this fact does not pose a problem for our implementation:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">add</code> query still updates its parent nodes, even though some of them correspond to some prefix and some suffix of the array instead of a contiguous subsegment.</li>
  <li>The <code class="language-plaintext highlighter-rouge">sum</code> query still computes the sum on the correct subsegment, even when <code class="language-plaintext highlighter-rouge">l</code> is on that wrapped prefix and logically “to the right” of <code class="language-plaintext highlighter-rouge">r</code> because eventually <code class="language-plaintext highlighter-rouge">l</code> becomes the last node on a layer and gets incremented, suddenly jumping to the first element of the next layer and proceeding normally after adding just the right nodes on the wrapped-around part of the tree (look at the dimmed nodes in the illustration).</li>
</ul>

<p>Compared to the top-down approach, we use half the memory and don’t have to maintain query ranges, which results in simpler and consequently faster code:</p>

<p><img src="../img/segtree-bottomup.svg" alt="" /></p>

<p>When running the benchmarks, we use the <code class="language-plaintext highlighter-rouge">sum(l, r)</code> procedure for computing a general subsegment sum and just fix <code class="language-plaintext highlighter-rouge">l</code> equal to <code class="language-plaintext highlighter-rouge">0</code>. To achieve higher performance on the prefix sum query, we want to avoid maintaining <code class="language-plaintext highlighter-rouge">l</code> and only move the right border like this:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">k</span> <span class="o">+=</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">k</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// if k is a right child</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="o">--</span><span class="p">];</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In contrast, this prefix sum implementation doesn’t work unless $n$ is not a power of two — because <code class="language-plaintext highlighter-rouge">k</code> could be on that wrapped-around part, and we’d sum almost the entire array instead of a small prefix.</p>

<p>To make it work for arbitrary array sizes, we can permute the leaves so that they are in the left-to-right logical order in the last two layers of the tree. In the example above, this would mean adding $3$ to all leaf indexes and then moving the last three leaves one level higher by subtracting $13$.</p>

<p>In the general case, this can be done using predication in a few cycles like this:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">last_layer</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">__lg</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

<span class="c1">// calculate the index of the leaf k</span>
<span class="kt">int</span> <span class="nf">leaf</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">k</span> <span class="o">+=</span> <span class="n">last_layer</span><span class="p">;</span>
    <span class="n">k</span> <span class="o">-=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">k</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>When implementing the queries, all we need to do is to call the <code class="language-plaintext highlighter-rouge">leaf</code> function to get the correct leaf index:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">leaf</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">k</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">leaf</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">k</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="o">--</span><span class="p">];</span>
        <span class="n">k</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The last touch: by replacing the <code class="language-plaintext highlighter-rouge">s += t[k--]</code> line with <a href="/hpc/pipelining/branchless">predication</a>, we can make the implementation branchless (except for the last branch — we still need to check the loop condition):</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">leaf</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="o">~</span><span class="n">k</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// will be replaced with a cmov</span>
        <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>When combined, these optimizations make the prefix sum queries run much faster:</p>

<p><img src="../img/segtree-branchless.svg" alt="" /></p>

<p>Notice that the bump in the latency for the prefix sum query starts at $2^{19}$ and not at $2^{20}$, the L3 cache boundary. This is because we are still storing $2n$ integers and also fetching the <code class="language-plaintext highlighter-rouge">t[k]</code> element regardless of whether we will add it to <code class="language-plaintext highlighter-rouge">s</code> or not. We can actually solve both of these problems.</p>

<h3 id="fenwick-trees">Fenwick trees</h3>

<p>Implicit structures are great: they avoid pointer chasing, allow visiting all the relevant nodes in parallel, and take less space as they don’t store metadata in nodes. Even better than implicit structures are <em>succinct</em> structures: they only require the information-theoretical minimum space to store the structure, using only $O(1)$ additional memory.</p>

<p>To make a segment tree succinct, we need to look at the values stored in the nodes and search for redundancies — the values that can be inferred from others — and remove them. One way to do this is to notice that in every implementation of prefix sum, we’ve never used the sums stored in right children — therefore, for computing prefix sums, such nodes are redundant:</p>

<!--

One way to do this is to use the fact that for every node $v$ with children $l$ and $r$, we have $s_v = s_l + s_r$, so we only need to store two of these values, and we can in "triangle" $(l, v, r)$

For any node $p$, its sum $s_p$ equals to the sum $(s_l + s_r)$ stored in its children nodes. Therefore, for any such "triangle" of nodes, we only need to store any two of $s_p$, $s_l$, or $s_r$, and we can restore the other one from the $s_p = s_l + s_r$ identity.

-->

<p><img src="../img/segtree-succinct.png" alt="" /></p>

<p><em>The Fenwick tree</em> (also called <em>binary indexed tree</em> — soon you’ll understand why) is a type of segment tree that uses this consideration and gets rid of all <em>right</em> children, essentially removing every second node in each layer and making the total node count the same as the underlying array.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">t</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// +1 because we use use one-based indexing</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>To store these segment sums compactly, the Fenwick tree ditches the Eytzinger layout: instead, in place of every element $k$ that would be a leaf in the last layer of a segment tree, it stores the sum of its first non-removed ancestor. For example:</p>

<ul>
  <li>the element $7$ would hold the sum on the $[0, 7]$ range ($282$),</li>
  <li>the element $9$ would hold the sum on the $[8, 9]$ range ($-86$),</li>
  <li>the element $10$ would hold the sum on the $[10, 10]$ range ($-52$, the element itself).</li>
</ul>

<p>How to compute this range for a given element $k$ (the left boundary, to be more specific: the right boundary is always the element $k$ itself) quicker than simulating the descend down the tree? Turns out, there is a smart bit trick that works when the tree size is a power of two and we use one-based indexing — just remove the least significant bit of the index:</p>

<ul>
  <li>the left bound for element $7 + 1 = 8 = 1000_2$ is $0000_2 = 0$,</li>
  <li>the left bound for element $9 + 1 = 10 = 1010_2$ is $1000_2 = 8$,</li>
  <li>the left bound for element $10 + 1 = 11 = 1011_2$ is $1010_2 = 10$.</li>
</ul>

<p>And to get the last set bit of an integer, we can use this procedure:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">lowbit</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This trick works by the virtue of how signed numbers are stored in binary using <a href="/hpc/arithmetic/integer">two’s complement</a>. When we compute <code class="language-plaintext highlighter-rouge">-x</code>, we implicitly subtract it from a large power of two: some prefix of the number flips, some suffix of zeros at the end remains, and the only one-bit that stays unchanged is the last set bit — which will be the only one surviving <code class="language-plaintext highlighter-rouge">x &amp; -x</code>. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>+90 = 64 + 16 + 8 + 2 = (0)10110
-90 = 00000 - 10110   = (1)01010
    → (+90) &amp; (-90)   = (0)00010
</pre></td></tr></tbody></table></code></pre></div></div>

<!-- More formally, a Fenwick tree is defined as the array $t_i = \sum_{k=f(i)}^i a_k$ where $f$ is some function for which $f(i) \leq i$. If $f$ is the "remove last bit" function (`x -= x & -x`), then both query and update would only require updating $O(\log n)$ different $t$. -->

<p>We’ve established what a Fenwick tree is just an array of size <code class="language-plaintext highlighter-rouge">n</code> where each element <code class="language-plaintext highlighter-rouge">k</code> is defined to be the sum of elements from <code class="language-plaintext highlighter-rouge">k - lowbit(k) + 1</code> and <code class="language-plaintext highlighter-rouge">k</code> inclusive in the original array, and now it’s time to implement some queries.</p>

<p>Implementing the prefix sum query is easy. The <code class="language-plaintext highlighter-rouge">t[k]</code> holds the sum we need except for the first <code class="language-plaintext highlighter-rouge">k - lowbit(k)</code> elements, so we can just add it to the result and then jump to <code class="language-plaintext highlighter-rouge">k - lowbit(k)</code> and continue doing this until we reach the beginning of the array:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">-=</span> <span class="n">lowbit</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<!-- In a segment tree, this is equivalent to starting at the leaf `k` and jumping straight to the first ancestor that is a left child: -->

<p>Since we are repeatedly removing the lowest set bit from <code class="language-plaintext highlighter-rouge">k</code>, and also since this procedure is equivalent to visiting the same left-child nodes in a segment tree, each <code class="language-plaintext highlighter-rouge">sum</code> query can touch at most $O(\log n)$ nodes:</p>

<p><img src="../img/fenwick-sum.png" alt="A path for a prefix sum query in a Fenwick tree" /></p>

<p>To slightly improve the performance of the <code class="language-plaintext highlighter-rouge">sum</code> query, we use <code class="language-plaintext highlighter-rouge">k &amp;= k - 1</code> to remove the lowest bit in one go, which is one instruction faster than <code class="language-plaintext highlighter-rouge">k -= k &amp; -k</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&amp;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Unlike all previous segment tree implementations, a Fenwick tree is a structure where it is easier and more efficient to calculate the sum on a subsegment as the difference of two prefix sums:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="c1">// [l, r)</span>
<span class="kt">int</span> <span class="nf">sum</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="n">sum</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The update query is easier to code but less intuitive. We need to add a value <code class="language-plaintext highlighter-rouge">x</code> to all nodes that are left-child ancestors of leaf <code class="language-plaintext highlighter-rouge">k</code>. Such nodes have indices <code class="language-plaintext highlighter-rouge">m</code> larger than <code class="language-plaintext highlighter-rouge">k</code> but <code class="language-plaintext highlighter-rouge">m - lowbit(m) &lt; k</code> so that <code class="language-plaintext highlighter-rouge">k</code> is included in their ranges.</p>

<p>All such indices need to have a common prefix with <code class="language-plaintext highlighter-rouge">k</code>, then a <code class="language-plaintext highlighter-rouge">1</code> where it was <code class="language-plaintext highlighter-rouge">0</code> in <code class="language-plaintext highlighter-rouge">k</code>, and then a suffix of zeros so that that <code class="language-plaintext highlighter-rouge">1</code> canceled and the result of <code class="language-plaintext highlighter-rouge">m - lowbit(m)</code> is less than <code class="language-plaintext highlighter-rouge">k</code>. All such indices can be generated iteratively like this:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">k</span> <span class="o">+=</span> <span class="n">k</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">k</span><span class="p">)</span>
        <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Repeatedly adding the lowest set bit to <code class="language-plaintext highlighter-rouge">k</code> makes it “more even” and lifts it to its next left-child segment tree ancestor:</p>

<p><img src="../img/fenwick-update.png" alt="A path for an update query in a Fenwick tree" /></p>

<p>Now, if we leave all the code as it is, it works correctly even when $n$ is not a power of two. In this case, the Fenwick tree is not equivalent to a segment tree of size $n$ but to a <em>forest</em> of up to $O(\log n)$ segment trees of power-of-two sizes — or to a single segment tree padded with zeros to a large power of two, if you like to think this way. In either case, all procedures still work correctly as they never touch anything outside the $[1, n]$ range.</p>

<!-- Sometimes people use `k -= k & -k` to iterate when processing the `sum` query, which makes this implementation delightfully symmetric. -->

<p>The performance of the Fenwick tree is similar to the optimized bottom-up segment tree for the update queries and slightly faster for the prefix sum queries:</p>

<p><img src="../img/segtree-fenwick.svg" alt="" /></p>

<p>There is one weird thing on the graph. After we cross the L3 cache boundary, the performance takes off very rapidly. This is a <a href="/hpc/cpu-cache/associativity">cache associativity</a> effect: the most frequently used cells all have their indices divisible by large powers of two, so they get aliased to the same cache set, kicking each other out and effectively reducing the cache size.</p>

<p>One way to negate this effect is to insert “holes” in the layout like this:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="kr">inline</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">hole</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">k</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">t</span><span class="p">[</span><span class="n">hole</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">k</span> <span class="o">+=</span> <span class="n">k</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">k</span><span class="p">)</span>
        <span class="n">t</span><span class="p">[</span><span class="n">hole</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&amp;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">+=</span> <span class="n">t</span><span class="p">[</span><span class="n">hole</span><span class="p">(</span><span class="n">k</span><span class="p">)];</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Computing the <code class="language-plaintext highlighter-rouge">hole</code> function is not on the critical path between iterations, so it does not introduce any significant overhead but completely removes the cache associativity problem and shrinks the latency by up to 3x on large arrays:</p>

<p><img src="../img/segtree-fenwick-holes.svg" alt="" /></p>

<p>Fenwick trees are fast, but there are still other minor issues with them. Similar to <a href="../binary-search">binary search</a>, the temporal locality of their memory accesses is not the greatest, as rarely accessed elements are grouped with the most frequently accessed ones. Fenwick trees also execute a non-constant number of iterations and have to perform end-of-loop checks, very likely causing a branch misprediction — although just a single one.</p>

<p>There are probably still some things to optimize, but we are going to leave it there and focus on an entirely different approach, and if you know <a href="../s-tree">S-trees</a>, you probably already know where this is headed.</p>

<h3 id="wide-segment-trees">Wide Segment Trees</h3>

<p>Here is the main idea: if the memory system is fetching a full <a href="/hpc/cpu-cache/cache-lines">cache line</a> for us anyway, let’s fill it to the maximum with information that lets us process the query quicker. For segment trees, this means storing more than one data point in a node. This lets us reduce the tree height and perform fewer iterations when descending or ascending it:</p>

<p><img src="../img/segtree-wide.png" alt="" /></p>

<p>We will use the term <em>wide (B-ary) segment tree</em> to refer to this modification.</p>

<p>To implement this layout, we can use a similar <a href="/hpc/compilation/precalc">constexpr</a>-based approach we used in <a href="../s-tree#implicit-b-tree-1">S+ trees</a>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// cache line size (in integers, not bytes)</span>

<span class="c1">// the height of the tree over an n-element array </span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">height</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">B</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">height</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">B</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// where the h-th layer starts</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">offset</span><span class="p">(</span><span class="kt">int</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">h</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">B</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">B</span><span class="p">;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">B</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">H</span> <span class="o">=</span> <span class="n">height</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
<span class="k">alignas</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="kt">int</span> <span class="n">t</span><span class="p">[</span><span class="n">offset</span><span class="p">(</span><span class="n">H</span><span class="p">)];</span> <span class="c1">// an array for storing nodes</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This way, we effectively reduce the height of the tree by approximately $\frac{\log_B n}{\log_2 n} = \log_2 B$ times ($\sim4$ times if $B = 16$), but it becomes non-trivial to implement in-node operations efficiently. For our problem, we have two main options:</p>

<ol>
  <li>We could store $B$ <em>sums</em> in each node (for each of its $B$ children).</li>
  <li>We could store $B$ <em>prefix sums</em> in each node (the $i$-th being the sum of the first $(i + 1)$ children).</li>
</ol>

<p>If we go with the first option, the <code class="language-plaintext highlighter-rouge">add</code> query would be largely the same as in the bottom-up segment tree, but the <code class="language-plaintext highlighter-rouge">sum</code> query would need to add up to $B$ scalars in each node it visits. And if we go with the second option, the <code class="language-plaintext highlighter-rouge">sum</code> query would be trivial, but the <code class="language-plaintext highlighter-rouge">add</code> query would need to add <code class="language-plaintext highlighter-rouge">x</code> to some suffix on each node it visits.</p>

<p>In either case, one operation would perform $O(\log_B n)$ operations, touching just one scalar in each node, while the other would perform $O(B \cdot \log_B n)$ operations, touching up to $B$ scalars in each node. We can, however, use <a href="/hpc/simd">SIMD</a> to accelerate the slower operation, and since there are no fast <a href="/hpc/simd/reduction">horizontal reductions</a> in SIMD instruction sets, but it is easy to add a vector to a vector, we will choose the second approach and store prefix sums in each node.</p>

<p>This makes the <code class="language-plaintext highlighter-rouge">sum</code> query extremely fast and easy to implement:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">H</span><span class="p">;</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">t</span><span class="p">[</span><span class="n">offset</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">h</span> <span class="o">*</span> <span class="n">b</span><span class="p">))];</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">add</code> query is more complicated and slower. We need to add a number only to a suffix of a node, and we can do this by <a href="/hpc/simd/masking">masking out</a> the positions that should not be modified.</p>

<p>We can pre-calculate a $B \times B$ array corresponding to $B$ such masks that tell, for each of $B$ positions within a node, whether a certain prefix sum value needs to be updated or not:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Precalc</span> <span class="p">{</span>
    <span class="k">alignas</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">[</span><span class="n">B</span><span class="p">][</span><span class="n">B</span><span class="p">];</span>

    <span class="k">constexpr</span> <span class="n">Precalc</span><span class="p">()</span> <span class="o">:</span> <span class="n">mask</span><span class="p">{}</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">B</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">B</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">k</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">constexpr</span> <span class="n">Precalc</span> <span class="n">T</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Apart from this masking trick, the rest of the computation is simple enough to be handled with <a href="/hpc/simd/intrinsics#gcc-vector-extensions">GCC vector types</a> only. When processing the <code class="language-plaintext highlighter-rouge">add</code> query, we just use these masks to bitwise-and them with the broadcasted <code class="language-plaintext highlighter-rouge">x</code> value to mask it and then add it to the values stored in the node:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="k">typedef</span> <span class="kt">int</span> <span class="n">vec</span> <span class="nf">__attribute__</span> <span class="p">((</span> <span class="n">vector_size</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="p">));</span>

<span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">round</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">k</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">B</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// = k / B * B</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vec</span> <span class="n">v</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">vec</span><span class="p">{};</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">H</span><span class="p">;</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">vec</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">[</span><span class="n">offset</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">+</span> <span class="n">round</span><span class="p">(</span><span class="n">k</span><span class="p">)];</span>
        <span class="k">auto</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">vec</span><span class="o">*</span><span class="p">)</span> <span class="n">T</span><span class="p">.</span><span class="n">mask</span><span class="p">[</span><span class="n">k</span> <span class="o">%</span> <span class="n">B</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">B</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">v</span> <span class="o">&amp;</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">k</span> <span class="o">&gt;&gt;=</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This speeds up the <code class="language-plaintext highlighter-rouge">sum</code> query by more than 10x and the <code class="language-plaintext highlighter-rouge">add</code> query by up to 4x compared to the Fenwick tree:</p>

<p><img src="../img/segtree-simd.svg" alt="" /></p>

<p>Unlike <a href="../s-tree">S-trees</a>, the block size can be easily changed in this implementation (by literally changing one character). Expectedly, when we increase it, the update time also increases as we need to fetch more cache lines and process them, but the <code class="language-plaintext highlighter-rouge">sum</code> query time decreases as the height of the tree becomes smaller:</p>

<p><img src="../img/segtree-simd-others.svg" alt="" /></p>

<p>Similar to the <a href="../s-tree/#modifications-and-further-optimizations">S+ trees</a>, the optimal memory layout probably has non-uniform block sizes, depending on the problem size and the distribution of queries, but we are not going to explore this idea and just leave the optimization here.</p>

<!-- Wide Fenwick trees make little sense. The speed of Fenwick trees comes from rapidly iterating over just the elements we need. -->

<h3 id="comparisons">Comparisons</h3>

<p>Wide segment trees are significantly faster compared to other popular segment tree implementations:</p>

<p><img src="../img/segtree-popular.svg" alt="" /></p>

<p>The relative speedup is in the orders of magnitude:</p>

<p><img src="../img/segtree-popular-relative.svg" alt="" /></p>

<p>Compared to the original pointer-based implementation, the wide segment tree is up to 200 and 40 times faster for the prefix sum and update queries, respectively — although, for sufficiently large arrays, both implementations become purely memory-bound, and this speedup goes down to around 60 and 15 respectively.</p>

<h3 id="modifications">Modifications</h3>

<p>We have only focused on the prefix sum problem for 32-bit integers — to make this already long article slightly less long and also to make the comparison with the Fenwick tree fair — but wide segment trees can be used for other common range operations, although implementing them efficiently with SIMD requires some creativity.</p>

<p><em>Disclaimer:</em> I haven’t implemented any of these ideas, so some of them may be fatally flawed.</p>

<p><strong>Other data types</strong> can be trivially supported by changing the vector type and, if they differ in size, the node size $B$ — which also changes the tree height and hence the total number of iterations for both queries.</p>

<p>It may also be that the queries have different limits on the updates and the prefix sum queries. For example, it is not uncommon to have only “$\pm 1$” update queries with a guarantee that the result of the prefix sum query always fits into a 32-bit integer. If the result could fit into 8 bits, we’d simply use a 8-bit <code class="language-plaintext highlighter-rouge">char</code> with block size of $B=64$ bytes, making the total tree height $\frac{\log_{16} n}{\log_{64} n} = \log_{16} 64 = 1.5$ times smaller and both queries proportionally faster.</p>

<p>Unfortunately, that doesn’t work in the general case, but we still have a way to speed up queries when the update deltas are small: we can <em>buffer</em> the updates queries. Using the same “$\pm 1$” example, we can make the branching factor $B=64$ as we wanted, and in each node, we store $B$ 32-bit integers, $B$ 8-bit signed chars, and a single 8-bit counter variable that starts at $127$ and decrements each time we update a node. Then, when we process the queries in nodes:</p>

<ul>
  <li>For the update query, we add a vector of masked 8-bit plus-or-minus ones to the <code class="language-plaintext highlighter-rouge">char</code> array, decrement the counter, and, if it is zero, <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#ig_expand=3037,3009,4870,6715,4845,3853,288,6570,90,7307,5993,2692,6946,6949,5456,6938,5456,1021,3007,514,518,7253,7183,3892,5135,5260,3915,4027,3873,7401,4376,4229,151,2324,2310,2324,591,4075,3011,3009,6130,4875,6385,5259,6385,6250,1395,7253,6452,7492,4669,4669,7253,1039,1029,4669,4707,7253,7242,848,879,848,7251,4275,879,874,849,833,6046,7250,4870,4872,4875,849,849,5144,4875,4787,4787,4787,3016,3018,5227,7359,7335,7392,4787,5259,5230,5230,5223,5214,6438,5229,488,483,6527,6527,6554,1829,1829,1829&amp;techs=AVX,AVX2&amp;text=cvtepi8_">convert</a> the values in the <code class="language-plaintext highlighter-rouge">char</code> array to 32-bit integers, add them to the integer array, set the <code class="language-plaintext highlighter-rouge">char</code> array to zero, and reset the counter back to 127.</li>
  <li>For the prefix sum query, we visit the same nodes but add <em>both</em> <code class="language-plaintext highlighter-rouge">int</code> and <code class="language-plaintext highlighter-rouge">char</code> values to the result.</li>
</ul>

<p>This update accumulation trick lets us increase the performance by up to 1.5x at the cost of using ~25% more memory.</p>

<p>Having a conditional branch in the <code class="language-plaintext highlighter-rouge">add</code> query and adding the <code class="language-plaintext highlighter-rouge">char</code> array to the <code class="language-plaintext highlighter-rouge">int</code> array is rather slow, but since we only have to do it every 127 iterations, it doesn’t cost us anything in the amortized sense. The processing time for the <code class="language-plaintext highlighter-rouge">sum</code> query increases, but not significantly — because it mostly depends on the slowest read rather than the number of iterations.</p>

<p><strong>General range queries</strong> can be supported the same way as in the Fenwick tree: just decompose the range $[l, r)$ as the difference of two prefix sums $[0, r)$ and $[0, l)$.</p>

<p>This also works for some operations other than addition (multiplication modulo prime, xor, etc.), although they have to be <em>reversible:</em> there should be a way to quickly “cancel” the operation on the left prefix from the final result.</p>

<p><strong>Non-reversible operations</strong> can also be supported, although they should still satisfy some other properties:</p>

<ul>
  <li>They must be <em>associative:</em> $(a \circ b) \circ c = a \circ (b \circ c)$.</li>
  <li>They must have an <em>identity element:</em> $a \circ e = e \circ a = a$.</li>
</ul>

<p>(Such algebraic structures are called <a href="https://en.wikipedia.org/wiki/Monoid">monoids</a> if you’re a snob.)</p>

<p>Unfortunately, the prefix sum trick doesn’t work when the operation is not reversible, so we have to switch to <a href="#wide-segment-trees">option one</a> and store the results of these operations separately for each segment. This requires some significant changes to the queries:</p>

<ul>
  <li>The update query should replace one scalar at the leaf, perform a <a href="/hpc/simd/reduction/#horizontal-summation">horizontal reduction</a> at the leaf node, and then continue upwards, replacing one scalar of its parent and so on.</li>
  <li>The range reduction query should, separately for left and right borders, calculate a vector with vertically reduced values on their paths, combine these two vectors into one, and then reduce it horizontally to return the final answer. Note that we still need to use masking to replace values outside of query with neutral elements, and this time, it probably requires some conditional moves/blending and either $B \times B$ precomputed masks or using two masks to account for both left and right borders of the query.</li>
</ul>

<p>This makes both queries much slower — especially the reduction — but this should still be faster compared to the bottom-up segment tree.</p>

<p><strong>Minimum</strong> is a nice exception where the update query can be made slightly faster if the new value of the element is less than the current one: we can skip the horizontal reduction part and just update $\log_B n$ nodes using a scalar procedure.</p>

<p>This works very fast when we mostly have such updates, which is the case, e.g., for the sparse-graph Dijkstra algorithm when we have more edges than vertices. For this problem, the wide segment tree can serve as an efficient fixed-universe min-heap.</p>

<p><strong>Lazy propagation</strong> can be done by storing a separate array for the delayed operations in a node. To propagate the updates, we need to go top to bottom (which can be done by simply reversing the direction of the <code class="language-plaintext highlighter-rouge">for</code> loop and using <code class="language-plaintext highlighter-rouge">k &gt;&gt; (h * b)</code> to calculate the <code class="language-plaintext highlighter-rouge">h</code>-th ancestor), <a href="/hpc/simd/moving/#broadcast">broadcast</a> and reset the delayed operation value stored in the parent of the current node, and apply it to all values stored in the current node with SIMD.</p>

<p>One minor problem is that for some operations, we need to know the lengths of the segments: for example, when we need to support a sum and a mass assignment. It can be solved by either padding the elements so that each segment on a layer is uniform in size, pre-calculating the segment lengths and storing them in the node, or using predication to check for the problematic nodes (there will be at most one on each layer).</p>

<!--

**Persistent** trees

We mostly focused on the prefix sum problem, but this general structure can be used for other problems handled by segment trees:

- General sums and other reductions.
- Range minimum sum queries.
- Fixed-universe heaps.

Some more exotic applications, reliant on there being pointers, are expectedly harder. To implement dynamic trees, we could store the mapping between the node number and the tree in a hash table. For more complicated cases, such as whether wide segment trees can help in implementing persistent trees is an open question.

why b-ary Fenwick tree is not a good idea

-->

<h3 id="acknowledgements">Acknowledgements</h3>

<p>Many thanks to Giulio Ermanno Pibiri for collaborating on this case study, which is largely based on his 2020 paper “<a href="https://arxiv.org/pdf/2006.14552.pdf">Practical Trade-Offs for the Prefix-Sum Problem</a>” co-authored with Rossano Venturini. I highly recommend reading the original article if you are interested in the details we’ve skipped through here for brevity.</p>

<!-- It has some more detailed discussions, as well as some other implementations or branchless top-down segment tree and why b-ary Fenwick tree is not a good idea. Intermediate structures we've skipped here. -->

<p>The code and some ideas regarding bottom-up segment trees were adapted from a 2015 blog post “<a href="https://codeforces.com/blog/entry/18051">Efficient and easy segment trees</a>” by Oleksandr Bacherikov.</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:tcs">
      <p>Segment trees are rarely mentioned in the theoretical computer science literature because they are relatively novel (invented ~2000), mostly don’t do anything that <a href="https://en.wikipedia.org/wiki/Tree_(data_structure)">any other binary tree</a> can’t do, and <em>asymptotically</em> aren’t faster — although, in practice, they often win by a lot in terms of speed. <a href="#fnref:tcs" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>


        <hr style="visibility: hidden;">
        <ul class="pager">
          
          <li class="previous">
            <a href="/2025/07/25/classical-dp/" data-toggle="tooltip"
              data-placement="top" title="Classical Dynamic Programming">
              Previous<br>
              <span>Classical Dynamic Programming</span>
            </a>
          </li>
          
          
          <li class="next">
            <a href="/2025/07/25/sliding-window/" data-toggle="tooltip"
              data-placement="top" title="Sliding Window">
              Next<br>
              <span>Sliding Window</span>
            </a>
          </li>
          
        </ul>
        <hr style="visibility: hidden;">

        

        
      </div>

      <!-- Side Catalog Container -->
      
      <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
        <div class="side-catalog">
          <hr class="hidden-sm hidden-xs">
          <h5>
            <a class="catalog-toggle" href="#">CATALOG</a>
          </h5>
          <ul class="catalog-body"></ul>
        </div>
      </div>
      

      <!-- Sidebar Container -->
      <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

        <!-- Featured Tags -->
        


<section>
    
        <hr class="hidden-sm hidden-xs">
    
    <h5><a href="/archive/">FEATURED TAGS</a></h5>
    <div class="tags">
        
        
        
        
        
        
                <a data-sort="0004" 
                    href="/archive/?tag=C%2B%2B"
                    title="C++"
                    rel="12">C++</a>
        
                <a data-sort="0000" 
                    href="/archive/?tag=Algorithms"
                    title="Algorithms"
                    rel="16">Algorithms</a>
    </div>
</section>


        <!-- Friends Blog -->
        
      </div>
    </div>
  </div>
</article>


<script src="/js/jekyll-tabs.js"></script>
<!-- add support for mathjax by voleking-->
<!--  -->








<!-- async load function -->
<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js", function () {
    anchors.options = {
      visible: 'hover',
      placement: 'right',
      // icon: '#'
    };
    anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
  })
</script>
<style>
  /* place left on bigger screen */
  @media all and (min-width: 800px) {
    .anchorjs-link {
      position: absolute;
      left: -0.75em;
      font-size: 1.1em;
      margin-top: -0.1em;
    }
  }
</style>


    <!-- Footer -->
<footer style="background-color: black; width: 100%; margin-top: 20px;">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  
  
  
  
  
  <li>
    <a target="_blank" href="https://github.com/shreyassn">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  <li>
    <a target="_blank" href="https://www.linkedin.com/in/shreyassn">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
</ul>

                <p class="copyright text-muted">
                    Copyright &copy; Shreyas's Blogs 2025
                    <br>
                    <!-- Powered by <a href="http://huangxuan.me">Hux Blog</a> |
                    <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="100px"
                        height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huxpro&repo=huxpro.github.io&type=star&count=true">
                    </iframe> -->
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Simple Jekyll Search -->
<script src="/js/simple-jekyll-search.min.js"></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
        var d = document, t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
        s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->







<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function () {
        var $nav = document.querySelector("nav");
        if ($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->



<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog(selector) {

        // interop with multilangual 
        if ('' == 'true') {
            _containerSelector = 'div.post-container.active'
        } else {
            _containerSelector = 'div.post-container'
        }

        // init
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        // clean
        $(selector).html('')

        // appending
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>



<!-- Multi-Lingual -->


<!-- Simple Jekyll Search -->
<script>
    // https://stackoverflow.com/questions/1912501/unescape-html-entities-in-javascript
    function htmlDecode(input) {
        var e = document.createElement('textarea');
        e.innerHTML = input;
        // handle case of empty input
        return e.childNodes.length === 0 ? "" : e.childNodes[0].nodeValue;
    }

    SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('search-results'),
        json: '',
        searchResultTemplate: '<div class="post-preview item"><a href="{url}"><h2 class="post-title">{title}</h2><h3 class="post-subtitle">{subtitle}</h3><hr></a></div>',
        noResultsText: 'No results',
        limit: 50,
        fuzzy: false,
        // a hack to get escaped subtitle unescaped. for some reason, 
        // post.subtitle w/o escape filter nuke entire search.
        templateMiddleware: function (prop, value, template) {
            if (prop === 'subtitle' || prop === 'title') {
                if (value.indexOf("code")) {
                    return htmlDecode(value);
                } else {
                    return value;
                }
            }
        }
    });

    $(document).ready(function () {
        var $searchPage = $('.search-page');
        var $searchOpen = $('.search-icon');
        var $searchClose = $('.search-icon-close');
        var $searchInput = $('#search-input');
        var $body = $('body');

        $searchOpen.on('click', function (e) {
            e.preventDefault();
            $searchPage.toggleClass('search-active');
            var prevClasses = $body.attr('class') || '';
            setTimeout(function () {
                $body.addClass('no-scroll');
            }, 400)

            if ($searchPage.hasClass('search-active')) {
                $searchClose.on('click', function (e) {
                    e.preventDefault();
                    $searchPage.removeClass('search-active');
                    $body.attr('class', prevClasses);  // from closure 
                });
                $searchInput.focus();
            }
        });
    });
</script>


<!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0" /> -->
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
